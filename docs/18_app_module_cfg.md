<div style="page-break-before:always;">
</div>

# <a name="app_module_config"></a>Приложение 4. Формат списка исполняемых модулей

Пример конфигурационного файла `module.cfg`:

```ini
    # module.cfg

    [Image1]
    type=KERNEL
    host_path=vmlinux
    coverage=False
    map=System.map
    textstart=0xffffffff81000000

    [Image2]
    type=USER
    host_path=exe/dpkg
    coverage=True
    debuginfo=exe/dpkg.dbg

    [Image3]
    type=USER
    host_path=exe/apt-get
    coverage=True

    [Image4]
    type=USER
    host_path=exe/cat
    coverage=True
    debuginfo=exe/cat-8.32-31.fc35.x86_64.debug
    tieddebug=exe/dwp
    vmidb=vmidb/Image4.bin

    [Image5]
    type= PYTHON
    host_path=lib/python3.9
    guest_path=/usr/bin/python3.9
    coverage=False
    debuginfo=lib/02f8a561c3abdb9c8d8c859d4243bd8c3f928f.debug
    vmidb=vmidb/Image5.bin
```

Конфигурационный файл содержит набор секций с префиксом *Image*.

В каждой такой секции описывается отдельный бинарный файл.


В этой секции могут быть объявлены следующие поля: *type*, *host_path*, *guest_path*, *coverage*, *map*, *textstart*, *debuginfo*, *tieddebug*, *vmidb*.

**Поле type**

Для каждого раздела типа *Image* обязательно нужно указать его тип, который может быть одним из следующих:

- *USER*: пользовательский модуль.
- *KERNEL*: модуль ядра.
- *PYTHON*: модуль Python.
- *JAVA*: модуль Java.
- *CSHARP*: модуль C#.
- *SHARED_LIBRARY*: модуль разделяемой библиотеки.

Обычно это поле заполняется автоматически либо при создании конфигурационного файла, либо при загрузке отладочной информации.


**Поля host_path и guest_path**

Каждый раздел типа *Image* обязательно должен содержать хотя бы одно из полей *host_path* или *guest_path*.

- *host_path*: путь к бинарному файлу в хостовой системе.

- *guest_path*: путь к бинарному файлу в гоствевой системе.

Рекомендуется использовать *guest_path*, так как указание *host_path* требует дополнительного этапа анализа — поиска модуля в гостевом образе.


**Поле coverage**

Для каждого раздела типа *Image* обязательно должен быть указать флаг *coverage*, который отвечает за попытку выгрузки исходного кода для данного бинарного файла (необходима для дальнейшего сбора покрытия кода). По умолчанию *coverage* установлен в значение "истина" для всех пользовательских модулей.


**Поля map, debuginfo и tieddebug**

- *map*: содержит путь к файлу с символьной информацией, сгенерированной
компилятором или дизассемблером IDA (при использовании IDA для генерации map файлов нужно выставлять галочку *Segmentation information*).

- *debuginfo*: указывает путь к ELF-файлу, содержащему основную отладочную информацию. (Получить информацию о местоположении этого файла можно с помощью команды *readelf -wk <ваш путь к бинарному файлу>*)

- *tieddebug*: указывает путь к ELF-файлу, который содержит альтернативные отладочные символы, дополнительно к тем, что указаны в *debuginfo*. ( Получить информацию о местоположении этого файла можно с помощью команды *readelf -wk <ваш путь к файлу с основной отладочной информацией>*)

Эти поля следует использовать, если вы предоставляете бинарный файл без отладочной информации и хотите получить более качественный анализ, например, для отображения имен функций в Snatch.


**Поле textstart**

<!--TODO: Переписать, так как тут упоминается module_config.py, который a) не существует б) Мы отказались от использования скриптов. -->

В разделах типа *Image* вместе с *map* может быть задано поле *textstart*.
Как правило, нет необходимости определять *textstart* вручную, потому что это может
делать скрипт *module_config.py*. Если же утилита вывела сообщение об ошибке,
необходимо проанализировать бинарный файл самостоятельно.

*textstart* используется, если адреса в символьном файле абсолютные, а в исполняемом файле нет.
Так как модуль может загружаться в разные места памяти, необходимо вычислить смещение каждой функции от начала секции .text.
В поле *textstart* как раз и указывается адрес начала секции *.text*.
Это поле нужно в редких случаях, например, для ядерных модулей (см. ниже). В остальных случаях можно ничего не указывать.

Чтобы получить информацию о секциях в исполняемом файле, можно использовать утилиту *readelf*:

```bash
    readelf -S <config_name>
```

Пример, когда *textstart* необходимо указывать:

```text
    map-файл:

    ffffffffa0000bed t cleanup_module
    ffffffffa00008c2 t logring_syslog_write_raw
    ffffffffa0000a4b t init_module
    ffffffffa000098d t logring_syslog_write

    вывод утилиты readelf:

    Section Headers:
    [Nr] Name              Type             Address           Offset
         Size              EntSize          Flags  Link  Info  Align
    [ 0]                   NULL             0000000000000000  00000000
         0000000000000000  0000000000000000           0     0     0
    [ 1] .text             PROGBITS         0000000000000000  00000040
         0000000000000c8c  0000000000000000  AX       0     0     4
```

Нас интересуют секции типа *PROGBITS*. Если у них указан нулевой адрес, то их не получится
сопоставить с map-файлом при его загрузке в *Natch*.
Поэтому необходимо вручную определить адрес секции *.text*.

Пример, когда *textstart* не нужен:

```text
    map-файл:

    00000006:000000000000C000       .init_proc
    00000007:000000000000C030       .wget_netrc_db_free
    00000007:000000000000C040       .wget_bar_update
    00000007:000000000000C050       .seteuid
    00000007:000000000000C060       .chdir
    00000007:000000000000C070       .fileno
    00000007:000000000000C080       .wget_list_free
    00000007:000000000000C090       .dup2
    00000007:000000000000C0A0       .printf

    вывод утилиты readelf:

    Section Headers:
    [Nr] Name              Type             Address            Offset
         Size              EntSize          Flags  Link  Info  Align
    [11] .init             PROGBITS         000000000000c000   0000c000
         0000000000000017  0000000000000000 AX     0     0     4
```

Адрес секции здесь указан и он соответствует адресам, записанным в map-файле,
поэтому параметр *textstart* можно не указывать.


**Поле vmidb**

Отладочная и символьная информация из исполняемых файлов может быть заранее разобрана и сохранена
во время работы конфигурационных скриптов. Путь к полученному хранилищу записывается в поле *vmidb*. Данное поле заполняется автоматически и не требует ручного вмешательства или корректировки.

